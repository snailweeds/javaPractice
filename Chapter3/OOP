접근 제어 지시자(access modifier): 클래스 외부에서 클래스의 멤버 변수, 메서드, 생성자 이용할 수 있는지 여부 지정하는 키워드
private: 같은 클래스 내부에서만 접근 가능
default: 같은 패키지 내부에서만 접근 가능
protected: 같은 패키지나 상속관계의 클래스에서 접근 가능하고 그 외 외부에서는 X
public: 클래스의 외부 어디서나 접근 가능
set()/get() 메서드: private으로 선언된 멤버 변수에 대해 접근, 수정할 수 있는 메서드를 public으로 제공
get() 메서드만 제공되는 경우 read-only 필드
정보은닉: private으로 제어한 멤버 변수도 public 메서드가 제공되면 접근 가능하지만 변수가 public으로 공개되었을 때보다 private일 때 각 변수에 대한 제한을 public 메서드에서 제어 가능

캡슐화(encapsulation): 꼭 필요한 정보와 기능만 외부에 오픈, 일관된 기능 구현, 오류 최소화

this: 인스턴스 자신의 메모리 가리키기, 생성자에서 또 다른 생성자 호출할 때 사용, 자신의 주소(참조값) 반환

협력(collaboration): 객체 간 협력

static 변수(클래스 변수, 정적 변수): 여러 인스턴스에서 공통으로 사용하는 변수
static int serialNum; -> 인스턴스가 생성될 때 만들어지는 변수가 아닌, 처음 프로그램이 메모리에 로딩될 때 메모리 할당, 인스턴스 생성과 상관 없이 사용 가능하므로 클래스 이름으로 직접 참조
static 변수는 인스턴스에서 공통으로 사용하는 영역

static 메서드 만들기: serialNum 변수를 private으로 선언하고 getter/setter 구현
인스턴스 생성 전에 호출 될 수 있으므로 static 메서드 내부에서는 인스턴스 변수를 사용할 수 X
static 메서드는 인스턴스 생성과 무관하게 클래스 이름으로 호출 될 수 있음
변수의 유효 범위(scope)와 생성과 소멸(life cycle)은 각 변수의 종류마다 다름
지역변수, 멤버 변수, 클래스 변수는 유효범위와 life cycle, 사용하는 메모리도 다름
https://gitlab.com/easyspubjava/javacoursework/-/raw/master/Chapter2/2-17/img/variable.png
static 변수는 프로그램이 메모리에 있는 동안 계속 그 영역을 차지하므로 너무 큰 메모리를 할당하는 것은 좋지 않음
클래스 내부의 여러 메서드에서 사용하는 변수는 멤버 변수로 선언하는 것이 좋음
멤버 변수가 너무 많으면 인스턴스 생성 시 쓸데없는 메모리가 할당
상황에 적절하게 변수를 사용해야 함

싱글톤 패턴: 프로그램에서 인스턴스가 단 한 개만 생성되어야 하는 경우 사용하는 디자인 패턴, static 변수, 메서드를 활용하여 구현

배열: 동일한 자료형의 순차적 자료 구조, 인덱스 연산자[]를 이용하여 빠른 참조가 가능, 물리적 위치와 논리적 위치가 동일, 배열의 순서는 0부터 시작, 자바에서는 객체 배열을 구현한 ArrayList를 많이 활용
배열의 길이와 요소의 개수는 동일하지 X

객체 배열 선언: 기본 자료형 배열은 선언과 동시에 배열의 크기만큼의 메모리가 할당되지만,
객체 배열의 경우엔 요소가 되는 객체의 주소가 들어갈(4바이트, 8바이트) 메모리만 할당되고(null) 각 요소 객체는 생성하여 저장해야 함
객체 배열 복사: System.arrayCopy(src, srcPos, dest, destPos, length)
얕은 복사: 객체 주소만 복사되어 한쪽 배열의 요소를 수정하면 같이 수정, 두 배열이 같은 객체를 가리킴
깊은 복사: 각각의 객체를 생성하여 그 객체의 값을 복사하여 배열이 서로 다른 객체를 가리킴

다차원 배열: 이차원 이상으로 구현된 배열, 평면이나 공간 활용한 프로그램 구현

java.util 패키지에서 제공되는 ArrayList
boolean add(E e): 요소 하나를 배열에 추가, E는 요소의 자료형 의미
int size(): 배열에 추가된 요소 전체 개수를 반환
E get(int index): 배열의 index 위치에 있는 요소 값 반환
E remove(int index): 배열의 index 위치에 있는 요소 값 제거하고 그 값 반환
boolean isEmpty(): 배열이 비어있는지 확인

클래스 상속: 새로운 클래스를 정의 할 때 이미 구현된 클래스를 상속(inheritance) 받아서 속성이나 기능을 확장하여 클래스를 구현, class B extends A, 단일 상속(single inheritance)만을 지원
이미 구현된 클래스보다 더 구체적인 기능을 가진 클래스를 구현해야 할때 기존 클래스를 상속
상속하는 클래스: 상위 클래스, parent class, base class, super class
상속받는 클래스: 하위 클래스, child class, derived class, subclass

super: 하위 클래스에서 가지는 상위 클래스에 대한 참조 값
super(): 상위 클래스의 기본 생성자를 호출
하위 클래스에서 명시적으로 상위 클래스의 생성자를 호출하지 않으면 super() 호출
(이때 반드시 상위 클래스의 기본 생성자가 존재 해야 함)
상위 클래스의 기본 생성자가 없는 경우(다른 생성자가 있는 경우) 하위 클래스에서는 생성자에서는 super를 이용하여 명시적으로 상위 클래스의 생성자를 호출
super는 생성된 상위 클래스 인스턴스의 참조 값을 가지므로 super를 이용하여 상위 클래스의 메서드나 멤버 변수에 접근할 수 O
형 변환(업캐스팅): 상위 클래스로 변수를 선언하고 하위 클래스의 생성자로 인스턴스를 생성(Customer customerLee = new VIPCustomer();), 상위 클래스 타입의 변수에 하위 클래스 변수가 대입(VIPCustomer vCustomer = new VIPCustomer(); addCustomer(vCustomer); int addCustomer(Customer customer){})
상속 관계에서 모든 하위 클래스는 상위 클래스로 형 변환(업캐스팅)(그 역은 성립 X)

overriding(메서드 재정의): 상위 클래스에 정의된 메서드의 구현 내용이 하위 클래스에서 구현할 내용과 맞지 않는 경우 하위 클래스에서 동일한 이름의 메서드를 재정의
@Overriding: 재정의된 메서드라는 정보 제공
@FunctionalInterface: 함수형 I/F라는 정보 제공
@Deprecated: 이후 버전에서 사용되지 않을 수 있는 변수, 메서드 사용
@SuppressWarnings("경고"): 특정 경고가 나타나지 않도록 함

메서드(함수)의 이름 = 주소값
메서드는 명령어의 set 이고 프로그램이 로드되면 메서드 영역(코드 영역)에 명령어 set이 위치
해당 메서드가 호출 되면 명령어 set 이 있는 주소를 찾아 명령어 실행(메서드에서 사용하는 변수들은 스택 메모리에 위치)
인스턴스가 생성되면 변수는 힙 메모리에 따로 생성되지만, 메서드 명령어 set은 처음 한번만 로드
가상 메서드: 가상 메서드 테이블(vitual method table)에서 해당 메서드에 대한 address 가짐

다형성(polymorphism): 하나의 코드가 여러 자료형으로 구현되어 실행, 같은 코드에서 여러 다른 실행 결과 도출, 유연하고 확장성있고 유지보수가 편리한 프로그램 제작 가능

IS-A관계(inheritance): 일반적인(general) 개념과 구체적인(specific) 개념과의 관계, 상속은 클래스간의 결합도가 높은 설계, 상위 클래스의 수정이 많은 하위 클래스에 영향을 미칠 수 O, 계층구조가 복잡하거나 hierarchy가 높으면 좋지 X
HAS-A관계(composition): 클래스가 다른 클래스를 포함하는 관계 (변수로 선언), 코드 재사용의 가장 일반적인 방법, 상속하지 X

downcasting: 업캐스팅된 클래스를 다시 원래의 타입으로 형 변환, 하위 클래스로의 형 변환은 명시적으로 해야 함
instanceof: 원래 인스턴스의 형이 맞는지 여부를 체크하는 키워드로 맞으면 true 아니면 false를 반환

I/F: 모든 메서드가 추상 메서드로 선언됨 public abstract, 모든 변수는 상수로 선언됨 public static final
인터페이스를 구현한 클래스는 인터페이스 형으로 선언한 변수로 형 변환 가능(상속에서의 형 변환과 동일한 의미)
클래스 상속과 달리 구현 코드가 없으므로 여러 인터페이스를 구현할 수 있음 (cf. extends)
형 변환되는 경우 인터페이스에 선언된 메서드만 사용가능

I/F의 역할: 클래스나 프로그램이 제공하는 기능을 명시적으로 선언, 일종의 클라이언트 코드와의 약속이며 클래스나 프로그램이 제공하는 명세(specification), 클라이언트 프로그램은 인터페이스에 선언된 메서드 명세만 보고 이를 구현한 클래스 사용 가능, 어떤 객체가 하나의 인터페이스 타입이라는 것은 그 인터페이스가 제공하는 모든 메서드를 구현했다는 의미, 인터페이스를 구현한 다양한 객체 사용(다형성)

하나의 인터페이스를 여러 객체가 구현하게 되면 클라이언트 프로그램은 인터페이스의 메서드를 활용하여 여러 객체의 구현 사용 가능 (다형성)

I/F 상수: 모든 변수는 상수로 변환 public static final
I/F 추상 메서드: 모든 선언된 메서드는 추상 메서드 public abstract
I/F 디폴트 메서드: 구현을 가지는 메서드, 인터페이스를 구현하는 클래스들에서 공통으로 사용할 수 있는 기본 메서드, default 키워드 사용, 구현하는 클래스에서 재정의 가능, 인터페이스 구현한 클래스의 인스턴스가 생성되어야 사용 가능
I/F 정적 메서드: 인스턴스 생성과 상관 없이 인터페이스 타입으로 사용할 수 있는 메서드
I/F private 메서드: 인터페이스 구현한 클래스에서 사용하거나 재정의 불가, 인터페이스 내부에서만 사용하기 위해 구현하는 메서드, default 메서드나 static 메서드에서 사용

자바의 인터페이스는 구현 코드가 없으므로 하나의 클래스가 여러 인터페이스 구현 가능
디폴트 메서드가 중복되는 경우는 구현하는 클래스에서 재정의
여러 인터페이스를 구현한 클래스는 인터페이스 타입으로 형 변환 되는 경우 해당 인터페이스에 선언된 메서드만 사용 가능
구현 코드를 가지고 인스턴스가 생성된 경우만, 호출되는 디폴트 메서드의 경우 두 개의 인터페이스에서 중복되면 구현하는 클래스에서 반드시 재정의
I/F 상속: extends 키워드를 사용, 다중 상속이 가능하고 구현 코드의 상속이 아니므로 타입 상속
실무에서 프레임워크나 오픈소스와 함께 연동되는 구현을 하게 되면 클래스 상속과 인터페이스의 구현을 같이 사용하는 경우 多